using System;
using SplineMesh;
using UnityEngine;

namespace SplineMeshExtensions {
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineScaledPrefabInstantiatior : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = true;

        public GameObject prefab = null;
        public float startScale = 1, endScale = 0;
        public float spacing = 1, spacingRange = 0;
        public float offset = 0, offsetRange = 0;
        public bool isRandomYaw = false;
        public int randomSeed = 0;

        private void OnEnable() {
            string generatedName = "generated by "+GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => {
                toUpdate = true;
                foreach (CubicBezierCurve curve in spline.GetCurves()) {
                    curve.Changed.AddListener(() => toUpdate = true);
                }
            };
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                curve.Changed.AddListener(() => toUpdate = true);
            }
        }

        private void OnValidate() {
            toUpdate = true;
        }

        private void Update() {
            if (toUpdate) {
                Sow();
                toUpdate = false;
            }
        }

        public void Sow() {
            UOUtility.DestroyChildren(generated);

            UnityEngine.Random.InitState(randomSeed);
            if (spacing + spacingRange <= 0 ||
                prefab == null)
                return;

            float distance = 0;
            while (distance <= spline.Length) {
                CurveSample sample = spline.GetSampleAtDistance(distance);

                GameObject go;
                go = Instantiate(prefab, generated.transform);
                go.transform.localRotation = Quaternion.identity;
                go.transform.localPosition = Vector3.zero;
                go.transform.localScale = Vector3.one;

                // move along spline, according to spacing + random
                go.transform.localPosition = sample.location;
                float rangedScale = Mathf.Lerp(startScale, endScale, distance / spline.Length);
                go.transform.localScale = new Vector3(rangedScale, rangedScale, rangedScale);
                go.transform.rotation = sample.Rotation;
                
                // rotate with random yaw
                if (isRandomYaw)
                {
                    go.GetComponentInChildren<Transform>().Rotate(0, 0, UnityEngine.Random.Range(0, 360));
                }

                // move orthogonaly to the spline, according to offset + random
                var binormal = (Quaternion.LookRotation(sample.tangent, sample.up) * Vector3.right).normalized;
                var localOffset = offset + UnityEngine.Random.Range(0, offsetRange * Math.Sign(offset));
                localOffset *=  sample.scale.x;
                binormal *= localOffset;
                go.transform.position += binormal;

                distance += spacing + UnityEngine.Random.Range(0, spacingRange);
            }
        }
    }
}
